一：选择题

1、一个C 语言程序总是从( B )开始执行

A.主过程

B.主函数

C.子程序

D.主程序

2、下列字符串是标识符的是( A )

A、_HJ

B、9_student

C、long

D、LINE 1

3、若x是 int 型变量,y是 flat 型变量,所用的 scanf 调用语句格式为scanf("x=%d,y=%f,&x.&y);则为了将 10 和 66.6 分别赋给x 和y,正确的输入应是:( A )

A、x=10,y=66.6<回车>

B、10 66.6<回车>

C、10<回车>66.6<回车>

D、x=10<回车>y=66.6<回车>

4、下述 for 循环语句( B )

```c
int i,k:
for(i=0.k=-1:k=1;i++,k++)
printf("****");
```

A、判断循环结束的条件非法

B、是无限循环

C、只循环一次

D、一次也不循环

5、在定义 int a[10]:之后，对a 的引用正确的是( D )

A、a[10]

B、a[6.3]

C、a(6)

D、a[10-10]

6、在执行 int a[ ] [3]={1,2.3.4.5,6};语句后，a[1] [0]的值是( A )

A、4

B、1

C、2

D、5

7、在 C 语言程序中，以下描述正确的是( D )

A、函数的定义可以嵌套，但函数的调用不可以嵌套

B、函数的定义不可以嵌套，但函数的调用可以嵌套

C、函数的定义和函数的调用均不可以嵌套

D、函数的定义和函数的调用均可以嵌套

8、在调用函数时，如果实参是简单变量(非指针型)，它与对应形参之间的数据传递方式是( B )

A、地址传递

B、单向值传递

C、由实参传给形参，再由形参传回实参

D、传递方式由用户指定

9、若有定义:int a[3] [4]:，( )不能表示数组元素a [1] [1] ( D )

A、* (a[1]+1)

B、* (&a[1] [1])

C、(* (a+1)[1])

D、* (a+5)

10、在说明语句:int *  f( ):中，标识符代表的是( D )

A、一个用于指向整型数据的指针变量

B、一个用于指向一维数组的指针

C、一个用于指向函数的指针变量

D、一个返回值为指针型的函数名

11、有如下程序段

```c
int*p ,a=10 ,b=1 ;
p=&a; a=*p+b;
```

执行该程序段后，a 的值为( B )

A、12

B、11

C、10

D、编译错误

12、若有以下说明:
`int a[10]={1，2，3，4，5，6，7，8，9，10}，* p=a ;`

则数值为6的表达式是( C )

A、* p+6

B、* (p+6)

C、 *p+=5

D、p+5

13、以下对枚举类型名的定义中正确的是( B )

A、enum a={one ，two ，three}; 

B、enum a{one=9 ，two=-1 ，three} ;

C、enum a={"one”，"two”，"three"};

D、enum a{"one”，"two”，"threc"};

14、设有以下说明语句(  )
`struct stu { int a ; float b ;}stutype ;`

则下面的叙述不正确的是

A、struct是结构体类型的关键字

B、struct stu 是用户定义的结构体类型

C、stutype 是用户定义的结构体类型名

D、a和b都是结构体成员名

15、下面对的叙述中不正确的是( A )

A、用typedef 可以定义各种类型名，但不能用来定义变量

B、用typedef 可以增加新类型

C、用typedef只是将已存在的类型用一个新的标识符来代表

D、使用 typedef 有利于程序的通用和移植

二：判断题

1、在C程序中，% 是只能用于整数运算的运算符 ( x )

2、若 a=3,b=2,c=1,则逻辑表达式"(a>b)==c"的值为真( √ )

3、已知a=3,b=4.c=5.则逻辑表达式!(a+b)+c-1 && b+c/2 的值为0( x )

4、语句if(a>b) printf(“%d",a); else printf (”%d",b):可以用条件表达式a>b?a:b 取代  **取代这个词尚存疑惑**

5、for 循环的三个表达式都可以省略 ( √ )

6、for 语句的循环体至少执行一次 ( X )

7、定义 int x[5],n;则 x=x+n:或 x++:都是正确的.( x )

8、变量根据其作用域的范围可以分作局部变量和全局变量( √ )

9、设有如下定义:int * p; *p=100:则 printf(”%d",p);的输出结果是100.( x )

10、使几个不同的变量共占同一段内存的结构.称为”结构体"类型( √ )

三：简答题、

1、说明 C 语言中的基本数据类型有哪些?每种类型所占空间(在 32 位系统中)

1. **int**: 通常占用 4 字节（32 位），可以存储整数值，包括正数、负数和零。

2. **char**: 通常占用 1 字节（8 位），用来存储字符数据，例如字母、数字和符号。

3. **float**: 通常占用 4 字节（32 位），用来存储单精度浮点数，适合表示小数，但精度相对较低。

4. **double**: 通常占用 8 字节（64 位），用来存储双精度浮点数，具有更高的精度，适合表示大范围的小数值。

5. **short**: 通常占用 2 字节（16 位），用来存储较小的整数值，范围比 int 小。

6. **long**: 通常占用 4 字节（32 位），用来存储较大的整数值，范围比 int 大。

7. **long long**: 通常占用 8 字节（64 位），用来存储非常大的整数值，范围比 long 大。

8. **unsigned**: 这是一个修饰符，可以与上述整数类型结合使用，用来表示无符号整数，即只能表示非负数。

2、C 语言标识符构成的原则

C 语言标识符（Identifiers）是用于命名变量、函数、数组等程序实体的名称。标识符必须遵守以下几个原则：

1. **由字母、数字和下划线组成**：标识符可以包含大写字母（A-Z）、小写字母（a-z）、数字（0-9）以及下划线（_）。标识符不能以数字开头。

2. **区分大小写**：C 语言是区分大小写的，因此大写字母和小写字母被视为不同的字符。例如，`myVariable` 和 `myvariable` 被认为是不同的标识符。

3. **不能使用关键字**：不能使用 C 语言的保留关键字（reserved keywords）作为标识符，因为这些关键字具有特殊含义，如 `if`、`while`、`for` 等。标识符也不能与标准库函数名称冲突。

此外，标识符的长度是没有固定限制的，但不同的编译器可能会限制标识符的最大长度，通常在几百个字符之内。尽管标识符可以包含数字，但最好选择具有描述性意义的名称，以提高代码的可读性。

3、说明 = 运算符和 ==运算符的区别。

在 C 语言中，`=` 运算符和 `==` 运算符是两个完全不同的运算符，它们有不同的用途和含义。

1. **`=` 运算符**（赋值运算符）：
   - 用途：`=` 用于将右侧的值赋给左侧的变量。它将右侧的表达式的值赋给左侧的操作数（通常是一个变量）。
   - 示例：`x = 5;` 表示将值 5 赋给变量 x。

2. **`==` 运算符**（相等运算符）：
   - 用途：`==` 用于比较左侧和右侧的操作数是否相等。它用于在条件语句中判断两个值是否相等。
   - 示例：`if (x == 5)` 表示如果变量 x 的值等于 5，执行条件块内的代码。

要理解它们的区别，关键是记住它们的不同用途。`=` 用于赋值，将右侧的值存储到左侧的变量中，而 `==` 用于比较两个值是否相等。混淆它们可能导致错误，例如，如果你意外地使用 `=` 而不是 `==` 来进行条件判断，将改变变量的值，而不是进行比较。因此，在编程中应格外小心使用这两个运算符，以避免逻辑错误。

4、说明 while 循环和do while 循环的区别。

在 C 语言中，`while` 循环和 `do...while` 循环是两种不同类型的循环结构，它们之间有一些关键区别：

1. **条件判断的时机**：
   - **`while` 循环**：在 `while` 循环中，条件表达式在循环体执行之前进行判断。如果条件不满足（即条件表达式的值为假），则循环体一次都不会执行。
   - **`do...while` 循环**：在 `do...while` 循环中，循环体至少会执行一次，然后在循环结束后才对条件表达式进行判断。这意味着即使条件一开始不满足，循环体仍会被执行一次。

2. **语法结构**：
   - **`while` 循环**：
     ```c
     while (条件) {
         // 循环体
     }
     ```
   - **`do...while` 循环**：
     ```c
     do {
         // 循环体
     } while (条件);
     ```

3. **适用场景**：
   - **`while` 循环**：适用于需要在进入循环前检查条件是否满足的情况。如果条件一开始不满足，循环体可能一次都不会执行。
   - **`do...while` 循环**：适用于至少执行一次循环体的情况，然后根据条件判断是否继续循环。它常用于需要先执行一些操作，然后检查是否需要再次执行的情况。

下面是一个示例，展示了这两种循环的不同之处：

```c
#include <stdio.h>

int main() {
    int i = 0;

    printf("Using while loop:\n");
    while (i < 0) {
        printf("This will not be printed.\n");
    }

    printf("Using do...while loop:\n");
    do {
        printf("This will be printed at least once.\n");
    } while (i < 0);

    return 0;
}
```

在上述示例中，`while` 循环的循环体不会执行，因为条件一开始就不满足，而 `do...while` 循环的循环体会执行一次，然后才对条件进行判断。

5、前置的++运算符和后置的++运算符的区别。

在 C 语言中，前置的 `++` 运算符（`++i`）和后置的 `++` 运算符（`i++`）都用于增加一个变量的值，但它们之间存在重要的区别：

1. **前置的 `++` 运算符 (`++i`)：**
   - 先对变量进行递增操作，然后返回递增后的值。
   - 递增操作是在表达式的计算之前执行的。
   - 适用于需要在使用变量之前先递增它的情况。

示例：
```c
int i = 5;
int result = ++i;
// 此时 i 的值为 6，result 的值也为 6
```

2. **后置的 `++` 运算符 (`i++`)：**
   - 先返回变量的当前值，然后再进行递增操作。
   - 递增操作是在表达式的计算之后执行的。
   - 适用于需要在使用变量后递增它的情况。

示例：
```c
int i = 5;
int result = i++;
// 此时 i 的值为 6，result 的值为 5
```

区别的关键在于递增操作的执行时机。前置 `++` 递增操作在表达式计算之前，而后置 `++` 递增操作在表达式计算之后。您可以根据具体需求来选择使用哪种形式的 `++` 运算符。

五、

1.

``` c
void maxvalue(int *a, int n, int *pmax)
{
    int i;

    *pmax = *a;

    for (i = 1; i < n; i++)
    {
        if (*(a + i) > *pmax)
        {
            *pmax = *(a + i);
        }
    }
}

int main()
{

    int a[8] = {10, -1, 8, 30, 90, -67, 0, 66};
    int max;
    maxvalue(a, 8, &max);
    printf("max=%d\n", max);
    return 0;
}
```

2.

```c
int main()
{

    int i, j;
    for (i = 1; i < 100; i++)
    {
        if (i % 3 == 0 && i % 10 == 6 && (j=i)!=0)
        {
            printf("%d\n", j);
        }
    }

    return 0;
}
```

六、

1.

```c
#include <stdio.h>

int main()
{

    int n = 0;
    scanf("%d", &n);
    if (n < 60)
    {
        printf("%c", 'E');
    }
    else if (n >= 60 && n < 70)
    {
        printf("%c", 'D');
    }
    else if (n >= 70 && n < 80)
    {
        printf("%c", 'C');
    }
    else if (n >= 80 && n < 90)
    {
        printf("%c", 'B');
    }
    else if (n >= 90 && n <= 100)
    {
        printf("%c", 'A');
    }
    else
    {
        printf("输入有误");
    }

    return 0;
}
```

2.

```c
#include<stdio.h>

int Min(int a,int b,int c)
{
    int n = a;
    n = n<b? n:b;
    n = n<c? n:c;
    return n;

}

int main()
{

    int a, b, c;
    scanf("%d %d %d",&a,&b,&c);
    printf("%d",Min(a,b,c));
    

    return 0;
}
```

3.

```c
#include<stdio.h>

int main()
{

    int sum = 0;
    for (int i = 1; i <= 100; i++)
    {
        if (i%2==0)
        {
            sum +=i; 
        }
        
    }
    printf("%d",sum);
    

    return 0;
}
```

4.

```c
#include <stdio.h>

int main()
{

    int srt[3][3];
    for (int i = 0; i < 3; i++)
    {
        for (int j = 0; j < 3; j++)
        {
            scanf("%d",&srt[i][j]);
        }
    }
    int sum = 0;
    for (int i = 0; i < 3; i++)
    {
        for (int j = 0; j < 3; j++)
        {
            if (i == j)
            {
                sum += srt[i][j];
            }
        }
    }
    printf("%d", sum);

    return 0;
}
```

5.

```c
#include <stdio.h>
#include <stdlib.h> // 为了使用动态内存分配函数

int main()
{
    int n = 0;
    printf("请输入数组大小: ");
    scanf("%d", &n);

    // 使用动态内存分配来创建一个数组，以容纳用户输入的整数
    int *arr = (int *)malloc((n + 1) * sizeof(int));

    if (arr == NULL)
    {
        printf("内存分配失败\n");
        return 1;
    }

    printf("请按从小到大的顺序输入整数:\n");
    for (int i = 0; i < n; i++)
    {
        scanf("%d", &arr[i]);
    }

    int input = 0;
    printf("请输入需要插入的整数:\n");
    scanf("%d", &input);

    // 插入新整数并保持数组有序
    int index;
    for (index = n - 1; index >= 0 && arr[index] > input; index--)
    {
        arr[index + 1] = arr[index];
    }
    arr[index + 1] = input;
    n++; // 数组大小增加了一个元素

    printf("排序后的数组:\n");
    for (int i = 0; i < n; i++)
    {
        printf("%d ", arr[i]);
    }

    // 释放动态分配的内存
    free(arr);

    return 0;
}
```

